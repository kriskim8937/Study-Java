## 자바 실행 환경
- 자바 언어의 역사
- JDK, JLE란

## 01 자바 프로그래밍 시작하기
- 01-1 프로그래밍과 자바
- 01-2 자바 개발 환경 설치하기
- 01-3 이클립스로 첫 프로그램 만들기

## 02 변수와 자료형
02-1 컴퓨터는 데이터를 어떻게 표현할까?
02-2 변수란 무엇일까?
02-3 변수가 저장되는 공간의 특성, 자료형
02-4 상수와 리터럴
02-5 형 변환

## 03 자바의 여러 가지 연산자
03-1 기본 연산자
03-2 비트 연산자

## 04 제어 흐름 이해하기
04-1 조건문
04-2 반복문

둘째마당
자바의 핵심, 객체 지향 프로그래밍

## 05 클래스와 객체 1
05-1 객체 지향 프로그래밍과 클래스
05-2 클래스 살펴보기
05-3 메서드
05-4 클래스와 인스턴스
05-5 생성자
05-6 참조 자료형
05-7 정보 은닉

## 06 클래스와 객체 2
06-1 this 예약어
06-2 객체 간 협력
06-3 static 변수
06-4 변수 유효 범위
06-5 static 응용 ? 싱글톤 패턴

## 07 배열과 ArrayList
07-1 배열이란?
07-2 다차원 배열
07-3 ArrayList 클래스 사용하기
07-4 배열 응용 프로그램

## 08 상속과 다형성
08-1 상속이란?
08-2 상속에서 클래스 생성과 형 변환
08-3 메서드 오버라이딩
08-4 다형성
08-5 다형성 활용하기
08-6 다운 캐스팅과 instanceof

## 09 추상 클래스
09-1 추상 클래스
09-2 템플릿 메서드
09-3 템플릿 메서드 응용하기
09-4 final 예약어

10 인터페이스
10-1 인터페이스란?
10-2 인터페이스와 다형성
10-3 인터페이스 요소 살펴보기
10-4 인터페이스 활용하기

셋째마당
자바 JDK로 프로그래밍 날개 달기

11 기본 클래스
11-1 Object 클래스
11-2 String 클래스
11-3 Wrapper 클래스
11-4 Class 클래스

12 컬렉션 프레임워크
12-1 제네릭
12-2 컬렉션 프레임워크
12-3 List 인터페이스
12-4 Set 인터페이스
12-5 Map 인터페이스

13 내부 클래스, 람다식, 스트림
13-1 내부 클래스
13-2 람다식
13-3 스트림

14 예외 처리
14-1 예외 클래스
14-2 예외 처리하기
14-3 예외 처리 미루기
14-4 사용자 정의 예외

15 자바 입출력
15-1 자바 입출력과 스트림
15-2 표준 입출력
15-3 바이트 단위 스트림
15-4 문자 단위 스트림
15-5 보조 스트림
15-6 직렬화
15-7 그 외 입출력 클래스


멀티 스레드
스레드 제어


제4부 애플릿과 사용자 인터페이스
애플릿과 그래픽
이벤트 처리
사용자 인터페이스 : AWT 
사용자 인터페이스 : SWING

CHAPTER 9 중첩 클래스와 중첩 인터페이스
09-1 중첩 클래스와 중첩 인터페이스 소개
09-2 익명 객체

1장. 네트워크 프로그래밍 시작
__InetAddress 클래스를 사용한 네트워크 주소
__NIO 지원
____URLConnection 클래스 사용
____버퍼와 채널을 이용한 URLConnection 클래스 사용
__클라이언트/서버 아키텍처
__간단한 에코 서버 생성
____간단한 에코 클라이언트 생성
____자바 8을 사용한 에코 서버와 클라이언트 지원
__UDP와 멀티캐스팅
____멀티캐스트 서버 생성
____멀티캐스트 클라이언트 생성
__확장성
____스레드 서버 생성
____스레드 서버 사용
__보안
____SSL 서버 생성
____SSL 클라이언트 생성
____보안 키 생성
__요약

2장. 네트워크 주소
__네트워크 기본
____네트워크 기본 이해
________네트워크 아키텍처와 프로토콜
__NetworkInterface 클래스 사용
____Mac 주소 획득
________특별한 Mac 주소 획득
________다중 MAC 주소 획득
__네트워크 주소 개념
____URL/URI/URN
____URI 클래스 사용
________URI 인스턴스 생성
________URI 부분 분리
____URL 클래스 사용
________URL 인스턴스 생성
________URL 부분 분리
____IP 주소와 InetAddress 클래스
________주소 정보 획득
________주소 범위 문제
________도달 가능성 테스트
____Inet4Address 소개
________IPv4의 사설 주소
________IPv4 주소 타입
________Inet4Address 클래스
________특별한 IPv4 주소
____Inet6Address 클래스 소개
________IPv6의 사설 주소
________Inet6Address 클래스
________특별한 IPv6 주소
____IP 주소 타입 테스트
________IPv4 호환 IPv6 주소 사용
__네트워크 속성 제어
__요약

3장. 네트워크 NIO 지원
__자바 NIO
__버퍼 소개
__채널을 사용한 타임 서버
____타임 서버 생성
____타임 클라이언트 생성
__채팅 서버/클라이언트 애플리케이션
____채팅 서버
____채팅 클라이언트
____서버/클라이언트 상호작용
____HelperMethods 클래스
________가변 길이 메시지 처리
____채팅 서버/클라이언트 애플리케이션 실행
__다중 클라이언트 처리
____부품 서버
____부품 클라이언트 핸들러
____부품 클라이언트
____부품 클라이언트/서버 실행
__비동기 소켓 채널
____비동기 서버 소켓 채널 서버 생성
____비동기 소켓 채널 클라이언트 생성
__기타 버퍼 작업
____대량 데이터 전송
____뷰 사용
____읽기 전용 버퍼 사용
__소켓 옵션 제어
__요약

4장. 클라이언트/서버 개발
__HTTP 프로토콜 구조
__HTTP 메시지의 특성
____요청 초기 라인 형식
____헤더 라인
____메시지 몸체
____클라이언트/서버 상호작용 예제
__HTTP 클라이언트/서버 애플리케이션에서 자바 소켓 지원
____간단한 HTTP 서버 구축
____간단한 HTTP 클라이언트 구축
__표준 자바 클래스를 사용한 클라이언트/서버 개발
____HttpURLConnection 클래스 사용
________URL 인코딩
____HTTPServer 클래스 사용
________간단한 HttpServer 클래스 구현
________응답 헤더 관리
__오픈소스 자바 HTTP 서버
__서버 구성
__쿠키 처리
__요약

5장. P2P 네트워크
__P2P 기능/특성
__애플리케이션 기반 P2P 네트워크
__P2P 애플리케이션용 자바 지원
__분산 해시 테이블
____DHT 컴포넌트
____DHT 구현
____JDHT 사용
__FreePastry 사용
____FreePastry 예제
________FreePastryExample 클래스의 이해
________FreePastryApplication 클래스의 이해
________특정 노드에게 메시지 전송
__요약

6장. UDP와 멀티캐스팅
__UDP에 대한 자바 지원
__TCP와 UDP
__UDP 클라이언트/서버
____UDP 서버 애플리케이션
____UDP 클라이언트 애플리케이션
____작동하는 UDP 클라이언트/서버
__UDP를 위한 채널 지원
____UDP 에코 서버 애플리케이션
____UDP 에코 클라이언트 애플리케이션
____작동하는 UDP 에코 클라이언트/서버
__UDP 멀티캐스팅
____UDP 멀티캐스트 서버
____UDP 멀티캐스트 클라이언트
____작동하는 UDP 멀티캐스트 클라이언트/서버
__채널에 의한 UDP 멀티캐스팅
____UDP 채널 멀티캐스트 서버
____UDP 채널 멀티캐스트 클라이언트
____작동하는 UDP 채널 멀티캐스트 클라이언트/서버
__UDP 스트리밍
____UDP 오디오 서버 구현
____UDP 오디오 클라이언트 구현
__요약

7장. 네트워크 확장성
__멀티스레드 서버 개요
__thread-per-request 접근법
____thread-per-request 서버
____thread-per-request 클라이언트
____작동하는 thread-per-request 애플리케이션
__Thread-per-connection 접근법
____thread-per-connection 서버
____thread-per-connection 클라이언트
____작동하는 thread-per-connection 애플리케이션
__스레드 풀
____ThreadPoolExecutor 클래스 특성
____간단한 스레드 풀 서버
____간단한 스레드 풀 클라이언트
____작동하는 스레드 풀 클라이언트/서버
____Callable와 스레드 풀
________Callable 사용
________Future 사용
__HttpServer 실행기 사용
__셀렉터 사용
____셀렉터 생성
____채널 등록
____타임 클라이언트/서버를 지원하는 셀렉터 사용
________채널 타임 서버
________날짜와 시간 클라이언트 애플리케이션
________작동하는 날짜와 시간 서버/클라이언트
__네트워크 타임아웃 처리
__요약

8장. 네트워크 보안
__보안
____보안 통신 용어
__암호화 기본
____대칭 암호화 기법
________키 생성
________대칭 키를 이용한 암호화 텍스트
________복호화 텍스트
____비대칭 암호화 기법
________비대칭 키 생성과 저장
________비대칭 키를 사용한 암호화/복호화 텍스트
________비대칭 키 파일 저장
__키스토어 생성
____keytool을 사용한 키스토어 생성과 유지
____Keytool 커맨드라인 인자
____자바를 사용한 키스토어 생성과 유지
__대칭 암호화 클라이언트/서버
____대칭 서버 애플리케이션
____대칭 클라이언트 애플리케이션
____작동하는 대칭 클라이언트/서버
__비대칭 암호화 클라이언트/서버
____비대칭 서버 애플리케이션
____비대칭 클라이언트 애플리케이션
____작동하는 비대칭 클라이언트/서버
__TLS/SSL
____SSL 서버
____SSL 클라이언트
____작동하는 SSL 클라이언트/서버
__보안 해시 함수
__요약

9장. 네트워크 상호운용성
__자바 바이트 순서
__기타 언어와의 인터페이스
____JVM 기반 언어와 인터페이스
____비JVM 언어와 인터페이스
__간단한 소켓을 이용한 통신
____자바 서버
____C# 클라이언트
____작동하는 클라이언트/서버
__미들웨어를 통한 상호운용성
____RESTful 서비스 생성
____RESTful 서비스 테스트
____RESTful 클라이언트 생성
__요약

1장 기본 네트워크 개념 1
네트워크 3
네트워크 계층 5
IP, TCP 그리고 UDP 12
인터넷 17
클라이언트/서버 모델 23
인터넷 표준 24

2장 스트림 31
출력 스트림 32
입력 스트림 38
필터 스트림 44
reader와 writer 55

3장 스레드 65
스레드 실행하기 68
스레드에서 데이터 반환하기 73
동기화 85
데드락 94
스레드 스케줄링 95
스레드 풀과 익스큐터 110

4장 인터넷 주소 115
InetAddress 클래스 117
Inet4Address 클래스와 Inet6Address 클래스 134
NetworkInterface 클래스 134
유용한 프로그램 138

5장 URL과 URI 147
URI 148
URL 클래스 154
URI 클래스 177
프록시 193
GET 메소드를 사용하여 서버 측 프로그램과 통신하기 198
패스워드로 보호된 사이트 접근하기 202

6장 HTTP 211
프로토콜 211
HTTP 메소드 221
요청 본문 224
쿠키 225

7장 URLConnection 클래스 233
URLConnection 열기 234
서버에서 데이터 읽기 236
헤더 읽기 237
캐시 249
연결 설정하기 259
클라이언트 요청 HTTP 헤더 설정하기 269
서버에 데이터 쓰기 271
URLConnection의 보안 고려 사항 278
MIME 미디어 타입 추측하기 278
HttpURLConnection 클래스 280

8장 클라이언트 소켓 297
소켓 사용하기 298
소켓 생성과 연결 313
소켓 정보 얻기 321
소켓 옵션 설정하기 324
소켓 예외 335
GUI 애플리케이션에서 소켓 336

9장 서버 소켓 351
ServerSocket 사용하기 352
로그 남기기 367
서버 소켓 만들기 375
서버 소켓 정보 가져오기 378
소켓 옵션 380
HTTP 서버 384

10장 보안 소켓 403
보안 통신 404
보안 클라이언트 소켓 만들기 407
암호화 조합 선택하기 411
이벤트 핸들러 416
세션 관리 417
클라이언트 모드 419
보안 서버 소켓 만들기 420
SSLServerSocket 설정하기 425

11장 논블럭 I/O 429
예제 클라이언트 431
예제 서버 436
버퍼 444
채널 466
준비된 것 선택하기 478

12장 UDP 483
UDP 프로토콜 484
UDP 클라이언트 486
UDP 서버 489
DatagramPacket 클래스 491
DatagramSocket 클래스 502
소켓 옵션 513
유용한 애플리케이션들 518
DatagramChannel 클래스 530

13장 IP 멀티캐스트 543
멀티캐스팅 544
멀티캐스트 소켓 다루기 555
간단한 두 예제 564

제1장 네트워크 프로그래밍의 원리와 기초 지식
1.1 컴퓨터 네트워크의 실현
1.2 IP에 의한 인터네트워킹
1.3 TCP/UDP에 의한 통신 모델
1.4 WWW-TCP커넥션을 이용한 클라이언트/서버형 서비스의 실례

제2장 Java에 의한 네트워크 프로그래밍
2.1 심플하고 명쾌한 Java언어
2.2 Java에서 이용할 수 있는 네트웍크 기능

제3장 Telnet과 FTP
3.1 Telnet의 동작과 기능
3.2 Telnet의 실현
3.3 FTP의 동작과 기능
3.4 FTP의 실현

제4장 전자 메일 프로그래밍
4.1 전자 메일의 구조
4.2 전자 메일 수신의 구조
4.3 SMTP에 의한 간이형 메일 송신 프로그램
4.4 POP3에 의한 간이형 메일 수신 프로그램
4.5 SMTP 수신 서버의 작성
4.6 전자 메일 클라이언트의 구현

제5장 네트워크 게임 프로그래밍
5.1 네트워크 게임의 설계
5.2 오리지널 게임 서버의 실현
5.3 시스템으로 구현

제6장 채트 프로그래밍
6.1 TCP 커넥션에 의한 채트 서버의 구성 방법
6.2 멀티캐스트에 의한 채트 프로그램

1. Introduction 19
1.1. ARM Architecture History 19
1.1.1. ARM 초기 제품 19
1.1.2. ARM7TDMI Family부터 ARM9 21
1.1.3. ARM10과 ARM11 Family 23
1.2. Cortex Family 개요 26
1.2.1. Cortex A-, R-, M-series 26
1.2.2. ARM Licenses 28
1.2.3. M0, M3, R4F, A8, A9 개요 28
1.3. ARM7 Architecture와 비교를 통한 Cortex-M3 특징 34
1.3.1. Harvard Architecture 34
1.3.2. Thumb-2 Instruction Set 35
1.3.3. Pipeline Branch Speculation 36
1.3.4. Cortex-M3 interrupt 37

2. Cortex-M3 Architecture 39
2.1. Cortex-M3 block diagram 39
2.2. Registers 42
2.2.1. 프로세서 모드와 Privilege levels 42
2.2.2. 스텍 42
2.2.3. Cortex-M3 Core 레지스터들 43
2.3. Thumb-2 Instruction Set Architecture (ISA) 52
2.3.1. Architecture profile 52
2.3.2. Thumb-2 52
2.4. Memory Map 55
2.4.1. 미리 정의된 Memory Map 55
2.4.2. Bit banding 56
2.4.3. 메모리 Endian 59
2.5. Exceptions and Interrupts 60
2.5.1. Exception 종류 60
2.5.2. Exception Priority & Nested 처리 61
2.5.3. ARM7, ARM9과의 비교 61
2.5.4. STM, LDM 처리시의 Interrupt 62
2.6. Nested Vectored Interrupt Controller 63
2.6.1. NVIC 특징 63
2.6.2. Tail chaining, late arrival, pop pre-emption 65
2.7. 기타 특징 68

3. STM32 CPU 특징 69
3.1. Features 69
3.2. STM32F103xx Device overview 72
3.3. STM32F103xx block diagram 74
3.4. Memory mapping 75
3.5. Booting mode 78
3.6. Low-power modes 80
3.7. Core peripherals 81
3.7.1. Nested vectored interrupt controller (NVIC) 81
3.7.2. System control block (SCB) 83
3.7.3. SysTick timer (STK) 84

4. Hardware Manual 85
4.1. Cortex-M3 기본 EVB (Mango-M32) 하드웨어 매뉴얼 85
4.1.1. Mango-M32 구조 86
4.1.2. Mango-M32 부품면 설명 87
4.1.3. Part #1 ? STM32F103xx MCU 88
4.1.4. Part #2 ? USB Connector 89
4.1.5. Part #3, #4, #5 ? RS232C 90
4.1.6. Part #6 ? 7 Segment LED 90
4.1.7. Part #7 ? BOOT Select Switch 92
4.1.8. Part #8, #9, #10 ? WKUP, USER, RESET 버튼 93
4.1.9. Part #11, #12 ? 12MHz, 32.768KHz Crystal 93
4.1.10. Part #13 ? Power LED 93
4.1.11. Part #14 ? Indicator LEDs 93
4.1.12. Part #15 ? Expansion Connector 94
4.1.13. Part #16 ? JTAG 커넥터 95
4.2. Cortex-M3 + ZigBee EVB (Mango-Z1) 하드웨어 매뉴얼 96
4.2.1. Mango-z1 부품 설명 97
4.2.2. Mango-z1 보드 구조도 97
4.2.3. Mango-z1 보드 하드웨어 99
4.2.4. User Keys 103
4.2.5. Indicator LEDs 105
4.2.6. USB 107
4.2.7. RS-232C 109
4.2.8. Power 112
4.2.9. RF Transceiver 113
4.2.10. 2.4GHz RF 114
4.2.11. Expansion Slot 115
4.2.12. JTAG 116

5. 개발 환경 구축 117
5.1. IAR workbench 환경 구축 117
5.1.1. Evaluation version 다운로드 117
5.1.2. IAR Embedded Workbench for ARM v.5.2 설치 118
5.2. RIDE7 환경 구축 120
5.2.1. RIDE7 다운로드 120
5.2.2. Ride7_7.30.10.0169.exe 설치 120
5.2.3. RKit-ARM_1.26.10.0130.exe 설치 122
5.2.4. RIDE7 프로젝트 구성 예제 123
5.3. STM Flash Loader 설치 124
5.4. 터미널 프로그램 설치 128
5.5. 참고 사항 - Error 사항 대처 방법 131
5.5.1. File Open error - Fatal Error[Pe005] 131
5.5.2. "assert_param" error - Error[Li005] 132
5.5.3. 빌드 Warning [Pa082] 133

6. Cortex-M3 기본 Firmware 프로그래밍 135
6.1. LED를 켜 보자 ? 무작정 따라하기 135
6.1.1. 폴더 구조 설정 135
6.1.2. IAR 환경 구성 및 빌드 136
6.1.3. RIDE7 환경 구성 및 빌드 144
6.1.4. Flash Download 151
6.1.5. 실행 157
6.2. 최초 프로그램 설명 159
6.2.1. LED 회로도 및 하드웨어 설명 159
6.2.2. (*(volatile unsigned *)0x40021018) |= 0x8 160
6.2.3. (*(volatile unsigned *)0x40010C04) |= 0x10 165
6.3. LED를 꺼 보자 171
6.3.1. LED 회로도 분석 171
6.3.2. 소스 파일 폴더 위치 172
6.3.3. main.c 변경 사항 172
6.3.4. 수행 결과 173
6.3.5. delay_int_count 173
6.3.6. GPIO Set Reset 레지스터 174
6.3.7. Port bit Reset register 174
6.3.8. Port bit Set Reset register 175
6.3.9. delay 시간에 관한 설명 176
6.4. 1초 delay_int_count 구현하기 177
6.4.1. 1초 delay의 정확도 177
6.4.2. delay 함수를 만드는 방법 177
6.4.3. CPU Clock에 관하여 178
6.4.4. Reset and clock control (RCC) 179
6.4.5. delay_int_count 어셈블리 코드 181
6.4.6. 1초 delay_int_count 결론 183
6.5. LED 모두 깜빡거리기 184
6.5.1. 소스 파일 폴더 위치 184
6.5.2. LED 회로도 및 위치 설명 184
6.5.3. main.c 변경 사항 185
6.5.4. GPIOB_CRL 레지스터 설정 186
6.5.5. GPIOx_BRR GPIOx_BSRR 레지스터 설정 187
6.5.6. 수행 결과 188
6.6. 고급스러운 코딩을 하자 1 190
6.6.1. 소스 파일 폴더 위치 190
6.6.2. platform_config.h 구현 - define의 활용 1 190
6.6.3. platform_config.h 구현 - define의 활용 2 193
6.6.4. GPIO_B_Output_Init 함수 구현 196
6.6.5. led.c 구현 198
6.6.6. IAR & RIDE7 빌드 201
6.6.7. 실행 결과 202
6.7. 고급스러운 코딩을 하자 2 203
6.7.1. 소스 파일 폴더 위치 203
6.7.2. 레지스터의 Address Offset - 상대 주소 지정 방식 203
6.7.3. 새로운 typedef - RCC_TypeDef 정의 205
6.7.4. GPIO_TypeDef 정의 208
6.7.5. 상대 주소 지정 방식 결론 212
6.8. Key가 눌린 것 알아채기 213
6.8.1. 소스 파일 폴더 위치 213
6.8.2. 회로도 및 보드 구성 분석 213
6.8.3. platform_config.h 변경 사항 215
6.8.4. GPIO Input mode 설정 216
6.8.5. Key Input 값 Read - GPIO Read 분석 218
6.8.6. key.c 분석 220
6.8.7. 빌드 및 실행 222
6.9. Hello World를 찍어보자 224
6.9.1. IAR에서 startup_stm32f10x_md.s 추가 224
6.9.2. GPIO_Init 분석 224
6.9.3. UART 일반 231
6.9.4. 회로도 분석 234
6.9.5. USART macro 및 typedef 분석 235
6.9.6. main 함수 검토 236
6.9.7. GPIO_Configuration 237
6.9.8. USART1_Init 238
6.9.9. USART_Init 함수 설명 244
6.9.10. UART 출력 함수 구현 250
6.9.11. 실행 결과 254
6.10. printf를 활용하자 255
6.10.1. semi-hosting 255
6.10.2. main.c 변경사항 259
6.10.3. 실행 결과 261
6.11. Get Character & 메뉴 구성 262
6.11.1. USART_FLAG_RXNE 262
6.11.2. USART_ReceiveData 구현 263
6.11.3. USART_GetCharacter 구현 263
6.11.4. 메뉴 구성 265
6.11.5. 수행 결과 267
6.12. 7-Segment Control 268
6.12.1. 회로도 분석 268
6.12.2. 7-segment 개요 268
6.12.3. GPIO 설정 및 기본 함수 구현 269
6.12.4. Seven_Segment_Test 구현 271
6.12.5. 7-segment로 숫자를 표현해 보자 272
6.12.6. 실행 결과 275
6.13. Clock Control 276
6.13.1. 회로도 및 클럭 소스 분석 276
6.13.2. Enable HSE 277
6.13.3. Flash access Latency 설정 278
6.13.4. HCLK, PCLK1, PCLK2 설정 280
6.13.5. PLL 설정 282
6.13.6. PLL ON 284
6.13.7. System clock switch 설정 285
6.13.8. 소스 코드 변경 사항 설명 286
6.13.9. LED Test 성능 비교 287
6.14. RCC_GetClocksFreq 구현 289
6.14.1. RCC_ClocksTypeDef 정의 289
6.14.2. SYSCLK_Frequency 구하기 289
6.14.3. HCLK_Frequency 구하기 292
6.14.4. PCLK1_Frequency 구하기 293
6.14.5. PCLK2_Frequency 구하기 294
6.14.6. ADCCLK_Frequency 구하기 295
6.14.7. System_Information 변경 사항 295
6.14.8. 수행 결과 296
6.15. 정확한 1초 Delay 구현 297
6.15.1. Cortex-M3 Exception 개요 297
6.15.2. STM32F10xxx Vector table 300
6.15.3. System Control Space 분석 303
6.15.4. NVIC Vector Table 설정 305
6.15.5. SysTick Configuration 307
6.15.6. Exception priority 311
6.15.7. NVIC_SetPriority 설정 313
6.15.8. SysTick interrupt handler 설정 317
6.15.9. 실행 결과 319
6.16. Key Interrupt 처리 320
6.16.1. 실행 결과 320
6.16.2. External interrupt/event controller (EXTI) 개요 321
6.16.3. NVIC Configuration 분석 324
6.16.4. EXTI Configuration 335
6.16.5. EXTI0_IRQHandler 342

7. Cortex-M3 및 802.15.4 ZigBee 통신 프로그래밍 345
7.1. Hello World 345
7.1.1. STMicroelectronics 라이브러리 적용 345
7.1.2. Hello World 빌드 - IAR case 348
7.1.3. Hello World 빌드 - RIDE7 case 352
7.1.4. 소스 분석 353
7.1.5. 수행 결과 357
7.1.6. 라이브러리 폴더 위치 변경 357
7.2. 메뉴 구성 및 LED & Key Control 360
7.2.1. USE_FULL_ASSERT - debug 부분 360
7.2.2. 소스 코드 변경 사항 365
7.2.3. RCC Get Clocks Frequency 367
7.3. Clock Control 369
7.3.1. 소스 변경 사항 369
7.3.2. 실행 결과 371
7.3.3. System Init 함수 설명 372
7.3.4. SetSysClock() 함수 설명 376
7.3.5. SetSysClockTo72() 함수 설명 376
7.4. 정확한 1초 Delay 구현 및 Key Interrupt 처리 379
7.4.1. 빌드 환경 추가 파일들 379
7.4.2. Interrupt Handler 구현 379
7.4.3. 소스 변경 사항 380
7.4.4. 실행 결과 383
7.5. In-Application Programming (IAP) - BootLoader 384
7.5.1. AN2557 다운로드 384
7.5.2. IAP 개요 385
7.5.3. IAP code 개요 386
7.5.4. IAP code 알고리즘 387
7.5.5. STM 라이브러리 사용 389
7.5.6. IAP project 소스 변경 내역 390
7.5.7. IAP 실행 399
7.5.8. User Program 만들기 1 - binary_template 399
7.5.9. IAP YModem Download 403
7.5.10. User Program 만들기 2 - Z1.Src004.KeyInterrupt 406
7.6. SPI 통신을 이용 CC2520 Chip ID 읽기 409
7.6.1. CC2520 2.4 GHz RF transceiver 410
7.6.2. CC2520 관련 자료 다운로드 410
7.6.3. 망고 Z1 회로도 분석 412
7.6.4. SPI (Serial Peripheral Interface) 통신 414
7.6.5. CC2520 레지스터 초기화 418
7.6.6. ZigBee_Test 프로그램 설명 428
7.6.7. SPI 초기화 428
7.6.8. CC2520 RF 초기화 433
7.6.9. Get Chip ID & Version 440
7.6.10. 빌드 및 실행 결과 442
7.7. One byte RF 통신 구현 444
7.7.1. 레지스터 값 출력 함수 구현 444
7.7.2. RF Channel 설정 446
7.7.3. PAN (Personal Area Network) ID & Short Address 설정 448
7.7.4. GPIO 0 Exception 설정 450
7.7.5. 초기 레지스터 설정 값 변경 사항 455
7.7.6. appSwitch Tx application 설명 456
7.7.7. appLight Rx application 설명 457
7.7.8. basicRfRxFrmDoneIsr() 함수 설명 458
7.7.9. 실행 결과 459
7.8. Multi-Packet Transmit 통신 구현 462
7.8.1. 실행 결과 462
7.8.2. 전송 패킷 & PER 계산 structure 구조 463
7.8.3. perTest_appTransmitter 설명 464
7.8.4. perTest_appReceiver 설명 468
7.9. USB HID Demo 471
7.9.1. STM 라이브러리 다운로드 및 폴더 설명 471
7.9.2. USB HID Demonstrator 다운로드 및 설치 472
7.9.3. 보드 구동 및 HID 시험 결과 473
7.9.4. USB 부분 회로 분석 480
7.9.5. EXTI line 18 USB Wakeup event 482
7.9.6. STM32 USB interface 484
7.9.7. STM32 USB 레지스터 설명 485
7.9.8. 레지스터 설정 관련 예 497

8. RTOS porting 503
8.1. FreeRTOS porting 503
8.1.1. FreeRTOS 소스 다운로드 503
8.1.2. FreeRTOS 일반 설명 504
8.1.3. FreeRTOS 디렉토리 및 파일 설명 506
8.1.4. MANGO-Z1 포팅 - Clock 설정 510
8.1.5. MANGO-Z1 포팅 - GPIO 설정 511
8.1.6. MANGO-Z1 포팅 - main() 함수 변경 514
8.1.7. 실행 결과 519
8.1.8. 참고 사항 - Compiler option 521
8.1.9. FreeRTOS 연구 - Overview 523
8.1.10. FreeRTOS 연구 - portTASK_FUNCTION 526
8.1.11. FreeRTOS 연구 - task state 527
8.1.12. FreeRTOS 연구 - Inter-task Communication 528
8.2. uC/OS-II porting 538
8.2.1. uC/OS-II 소스 다운로드 539
8.2.2. uC/OS-II 소스들간 관계 542
8.2.3. WRITE_REG, READ_REG 관련 수정 543
8.2.4. uC/OS-II 디렉토리 구조 544
8.2.5. 개발 환경 설정 및 빌드 545
8.2.6. probe_com_cfg.h 변경 사항 546
8.2.7. 클럭 설정 변경 사항 548
8.2.8. LED 관련 수정 사항 설명 548
8.2.9. task 생성 함수 OSTaskCreateExt 설명 552
8.2.10. LED task 생성 및 실행 결과 557
8.2.11. uC/OS-II 연구 - tick 설정 562
8.2.12. uC/OS-II 연구 - Critical Sections 564
8.2.13. uC/OS-II 연구 - task state 570
8.2.14. uC/OS-II 연구 - Scheduling Lock/Unlock, Task Suspend/Resume 571
8.2.15. uC/OS-II 연구 - Semaphore 571
8.2.16. uC/OS-II 연구 - Message Mailbox 574

__CHAPTER 1 핵심 개념 소개
____1.1 시스템 프로그래밍
____1.2 API와 ABI
____1.3 표준
____1.4 리눅스 프로그래밍의 개념
____1.5 시스템 프로그래밍 시작하기

__CHAPTER 2 파일 입출력
____2.1 파일 열기
____2.2 read()로 읽기
____2.3 write()로 쓰기
____2.4 동기식 입출력
____2.5 직접 입출력
____2.6 파일 닫기
____2.7 lseek()로 탐색하기
____2.8 지정한 위치 읽고 쓰기
____2.9 파일 잘라내기
____2.10 다중 입출력
____2.11 커널 들여다보기
____2.12 맺음말

__CHAPTER 3 버퍼 입출력
____3.1 사용자 버퍼 입출력
____3.2 표준 입출력
____3.3 파일 열기
____3.4 파일 디스크립터로 스트림 열기
____3.5 스트림 닫기
____3.6 스트림에서 읽기
____3.7 스트림에 쓰기
____3.8 사용자 버퍼 입출력 예제 프로그램
____3.9 스트림 탐색하기
____3.10 스트림 비우기
____3.11 에러와 EOF
____3.12 파일 디스크립터 얻어오기
____3.13 버퍼링 제어하기
____3.14 스레드 세이프
____3.15 표준 입출력 비평
____3.16 맺음말

__CHAPTER 4 고급 파일 입출력
____4.1 벡터 입출력
____4.2 epoll
____4.3 메모리에 파일 맵핑하기
____4.4 일반 파일 입출력에 대한 힌트
____4.5 동기화, 동기식, 비동기식 연산
____4.6 입출력 스케줄러와 성능
____4.7 맺음말

__CHAPTER 5 프로세스 관리
____5.1 프로그램, 프로세스, 스레드
____5.2 프로세스 ID
____5.3 새로운 프로세스 실행하기
____5.4 프로세스 종료하기
____5.5 자식 프로세스 종료 기다리기
____5.6 사용자와 그룹
____5.7 세션과 프로세스 그룹
____5.8 데몬
____5.9 맺음말

__CHAPTER 6 고급 프로세스 관리
____6.1 프로세스 스케줄링
____6.2 CFS 스케줄러
____6.3 프로세서 양보하기
____6.4 프로세스 우선순위
____6.5 프로세서 친화
____6.6 실시간 시스템
____6.7 리소스 제한

__CHAPTER 7 스레딩
____7.1 바이너리, 프로세스, 스레드
____7.2 멀티스레딩
____7.3 스레딩 모델
____7.4 스레딩 패턴
____7.5 동시성, 병렬성, 경쟁 상태
____7.6 동기화
____7.7 Pthread
____7.8 더 알아보기

__CHAPTER 8 파일과 디렉터리 관리
____8.1 파일과 메타데이터
____8.2 디렉터리
____8.3 링크
____8.4 파일 복사와 이동
____8.5 디바이스 노드
____8.6 대역 외 통신
____8.7 파일 이벤트 모니터링

__CHAPTER 9 메모리 관리
____9.1 프로세스 주소 공간
____9.2 동적 메모리 할당하기
____9.3 데이터 세그먼트 관리하기
____9.4 익명 메모리 맵핑
____9.5 고급 메모리 할당
____9.6 메모리 할당 디버깅
____9.7 스택 기반 할당
____9.8 메모리 할당 메커니즘 선택하기
____9.9 메모리 조작하기
____9.10 메모리 락 걸기
____9.11 게으른 할당

__CHAPTER 10 시그널
____10.1 시그널 개념
____10.2 시그널 관리 기초
____10.3 시그널 보내기
____10.4 재진입성
____10.5 시그널 모음
____10.6 시그널 블록
____10.7 고급 시그널 관리
____10.8 페이로드와 함께 시그널 보내기
____10.9 시그널은 미운 오리 새끼?

__CHAPTER 11 시간
____11.1 시간에 대한 자료구조
____11.2 POSIX 시계
____11.3 현재 시간 얻기
____11.4 현재 날짜와 시각 설정하기
____11.5 시간 다루기
____11.6 시스템 시계 조율
____11.7 잠들기와 대기
____11.8 타이머
